#summary How to use this project
#labels Phase-Implementation

The jain-sip-rfc3263-router library can be used in two ways: by specifying the !DefaultRouter as the router to be used by JAIN-SIP, or by using the vendor's Router and manually using the location service to add a route set.

==Router==

To use the jain-sip-rfc3263-router Router, simply set the `javax.sip.ROUTER_PATH` property to `"com.google.code.rfc3263.DefaultRouter"` in the Properties argument used to create a new !SipStack:

{{{
Properties properties = new Properties();
properties.setProperty("javax.sip.ROUTER_PATH", "com.google.code.rfc3263.DefaultRouter");

SipFactory factory = SipFactory.getInstance();
SipStack stack = factory.createSipStack(properties);
}}}

Note that `javax.sip.USE_ROUTER_FOR_ALL_URIS` property must either be absent or have a value of "true" for the router to be consulted for SIP URIs.

===Potential Problems===

The router is *stateless*, so a request with an identical Request-URI (or top Route header where appropriate) will always be sent to the same server or group of servers in a constant DNS environment (subject to DNS caching).  This may cause problems if the SIP server recommended by DNS is invalid or temporarily unavailable, in which case you may choose to use the location service manually (see below) to specify an alternative route, should one exist.

==Location Service==

The first thing you should attempt is to retrieve a list of hops from the location service.  You create a new instance of Locator by passing in a list of preferred transports, in order of preference.  Here, we are stating that we prefer TCP to UDP.  We then attempt to find the next hops for `sip:bob@biloxi.com`:

{{{
SipFactory factory = SipFactory.getInstance();
AddressFactory addressFactory = factory.createAddressFactory();
SipURI uri = addressFactory.createSipURI("bob", "biloxi.com");

List<String> transports = new LinkedList<String>();
transports.add(ListeningPoint.TCP);
transports.add(ListeningPoint.UDP);

Locator locator = new Locator(transports);
Queue<Hop> hops = locator.locate(uri);
}}}

When attempting to send a request you should poll the queue for the most appropriate hop.  The hop should be used to create a new route header like so:

{{{
HeaderFactory headerFactory = factory.createHeaderFactory();

SipURI routeUri = addressFactory.createSipURI(null, hop.getHost());
routeUri.setLrParam();
routeUri.setPort(hop.getPort());
if (hop.getTransport().equals("TLS")) {
    routeUri.setTransportParam("tcp");
} else if (hop.getTransport().equals("SCTP-TLS")) {
    routeUri.setTransportParam("sctp");
} else {
    routeUri.setTransportParam(hop.getTransport().toLowerCase());
}
Address routeAddress = addressFactory.createAddress(routeUri);
RouteHeader route = createRouteHeader(routeAddress);
}}}

You should then clone the request, add the route header to the top of route set, and send it using the most appropriate !SipProvider.  For a clear division of security, it might be simpler to use two different providers, and assign secure !ListeningPoint instances (TLS, SCTP-TLS) to one, and insecure !ListeningPoint instances (UDP, TCP, SCTP) to the other.

{{{
Request clonedRequest = (Request) request.clone();
clonedRequest.addFirst(route);

SipProvider sendingProvider;
if (hop.getTransport().endsWith("TLS")) {
    sendingProvider = secureProvider;
} else {
    sendingProvider = insecureProvider;
}
ClientTransaction tx = sendingProvider.getNewClientTransaction(clonedRequest);
tx.send();
}}}

If the transaction fails, poll the next hop from the queue and try again.  When the queue is empty, no more hops could be determined, and message sending has failed.  Depending on the type of failure, you may choose to try some or all of the hops again.

Depending on the time between request-sending attempts, you may wish to invoke the `locate` method again, to see if the DNS has been updated for the domain you are attempting to contact.